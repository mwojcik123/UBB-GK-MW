<!DOCTYPE html>
<meta charset="UTF-8" />
<html>
  <head>
    <title>WebGL Introduction</title>
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
      }

      canvas {
        display: block;
      }
    </style>

    <div style="text-align: center; color: white; background-color: black">
      SPACE - start animation, w - change shape, e - change colors
    </div>
    <script type="x-shader/x-vertex" id="vertex-shader">
      attribute vec2 vertexCoords;
      uniform float canvasWidth;
      uniform float canvasHeight;

      uniform float pointSize;
      uniform int shapeType;
      attribute vec3 vertexColor;
      varying vec3 fragColor;
      varying float fragShapeType;

      void main() {
        float x = vertexCoords.x / canvasWidth * 2.0 - 1.0;
        float y = 1.0 - vertexCoords.y / canvasHeight * 2.0;

        gl_Position = vec4(x, y, 0.0, 1.0);
        gl_PointSize = pointSize;
        fragColor = vec3(vertexColor);
        fragShapeType = float(shapeType);
      }
    </script>
    <script type="x-shader/x-fragment" id="fragment-shader">
        #ifdef GL_FRAGMENT_PRECISION_HIGH
           precision highp float;
        #else
           precision mediump float;
        #endif

      varying vec3 fragColor;
      varying float fragShapeType;

            const float pi=3.14;

      float polygon(float sides, float apotheme, vec2 point) {
            float angle = atan(point.x, point.y);
            angle -= floor(angle / pi / 2.0 * sides) / sides * pi * 2.0 - pi / sides;
        return cos(angle) * length(point) < apotheme ? 1.0 : 0.0;
      }

            void main() {
            float distance = distance(vec2(0.5), gl_PointCoord);
            gl_FragColor = vec4(fragColor, 1.0);
            if (fragShapeType > 4.0) {
                if (distance > polygon(fragShapeType, 0.4, vec2(gl_PointCoord.x - 0.5, gl_PointCoord.y - 0.5))) {
                    discard;
                }
             }
            }
    </script>

    <script>
      "use strict";

      var canvas;
      var gl;

      var canvasWidthLoc;
      var canvasHeightLoc;
      var pointSizeLoc;
      var vertexCoordsLoc;
      var vertexColorLoc;
      var vertexCoordsBuffer;
      var vertexColorBuffer;
      var shapeTypeLoc;
      var shapeSides = 8;

      var POINT_COUNT = 300;
      var POINT_SIZE = 50;

      var positions = new Float32Array(2 * POINT_COUNT);
      var velocities = new Float32Array(2 * POINT_COUNT);
      var colors = new Float32Array(3 * POINT_COUNT);

      var isRunning = false;
      var isColorRandom = false;

      function randomizeColors() {
        for (let i = 0; i < colors.length; i++) {
          colors[i] = Math.random();
        }
      }

      function changeShape() {
        var num = prompt("How many vertices do you want:", "8");
        shapeSides = parseInt(num);
        gl.uniform1i(shapeTypeLoc, shapeSides);
      }

      function render() {
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexCoordsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STREAM_DRAW);
        gl.vertexAttribPointer(vertexCoordsLoc, 2, gl.FLOAT, false, 0, 0);

        if (isColorRandom) {
          gl.enableVertexAttribArray(vertexColorLoc);
        } else {
          gl.disableVertexAttribArray(vertexColorLoc);
          gl.vertexAttrib3f(vertexColorLoc, 0.7, 0.2, 0.5);
        }

        gl.drawArrays(gl.POINTS, 0, POINT_COUNT);
        if (gl.getError() != gl.NO_ERROR) {
          console.log("During render, a GL error has been detected.");
        }
      }

      function createData() {
        randomizeColors();
        for (var i = 0; i < POINT_COUNT; i++) {
          positions[2 * i] = canvas.width / 2;
          positions[2 * i + 1] = canvas.height / 2;
          var speed = 2 + 8 * Math.random();
          var angle = 2 * Math.PI * Math.random();
          velocities[2 * i] = speed * Math.sin(angle);
          velocities[2 * i + 1] = speed * Math.cos(angle);
        }
      }

      function updateData() {
        for (var i = 0; i < POINT_COUNT; i++) {
          positions[2 * i] += velocities[2 * i];
          if (positions[2 * i] < POINT_SIZE / 2 && velocities[2 * i] < 0) {
            positions[2 * i] += 2 * (POINT_SIZE / 2 - positions[2 * i]);
            velocities[2 * i] = Math.abs(velocities[2 * i]);
          } else if (
            positions[2 * i] > canvas.width - POINT_SIZE / 2 &&
            velocities[2 * i] > 0
          ) {
            positions[2 * i] -=
              2 * (positions[2 * i] - canvas.width + POINT_SIZE / 2);
            velocities[2 * i] = -Math.abs(velocities[2 * i]);
          }
          positions[2 * i + 1] += velocities[2 * i + 1];
          if (
            positions[2 * i + 1] < POINT_SIZE / 2 &&
            velocities[2 * i + 1] < 0
          ) {
            positions[2 * i + 1] += 2 * (POINT_SIZE / 2 - positions[2 * i + 1]);
            velocities[2 * i + 1] = Math.abs(velocities[2 * i + 1]);
          } else if (
            positions[2 * i + 1] > canvas.height - POINT_SIZE / 2 &&
            velocities[2 * i + 1] > 0
          ) {
            positions[2 * i + 1] -=
              2 * (positions[2 * i + 1] - canvas.height + POINT_SIZE / 2);
            velocities[2 * i + 1] = -Math.abs(velocities[2 * i + 1]);
          }
        }
      }

      function handleKey(evt) {
        var key = evt.keyCode;
        console.log("key pressed with keycode = " + key);
        if (key == 69) {
          isColorRandom = !isColorRandom;
        }
        if (key == 87) {
          shapeSides = 4;
          changeShape();
        }
        if (key == 32) {
          isRunning = !isRunning;
          if (isRunning) {
            requestAnimationFrame(frame);
          }
        }
      }

      function initGL() {
        var program = createProgram(
          gl,
          "vertex-shader",
          "fragment-shader",
          "vertexCoords"
        );
        gl.useProgram(program);

        canvasWidthLoc = gl.getUniformLocation(program, "canvasWidth");
        canvasHeightLoc = gl.getUniformLocation(program, "canvasHeight");
        pointSizeLoc = gl.getUniformLocation(program, "pointSize");
        vertexCoordsLoc = gl.getAttribLocation(program, "vertexCoords");
        vertexColorLoc = gl.getAttribLocation(program, "vertexColor");
        shapeTypeLoc = gl.getUniformLocation(program, "shapeType");

        gl.uniform1f(canvasWidthLoc, canvas.width);
        gl.uniform1f(canvasHeightLoc, canvas.height);
        gl.uniform1f(pointSizeLoc, POINT_SIZE);

        vertexCoordsBuffer = gl.createBuffer();
        gl.enableVertexAttribArray(vertexCoordsLoc);

        vertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
        gl.vertexAttribPointer(vertexColorLoc, 3, gl.FLOAT, false, 0, 0);

        gl.clearColor(0, 0, 0, 1);

        if (gl.getError() != gl.NO_ERROR) {
          console.log("During initialization, a GL error has been detected.");
        }
      }

      function createProgram(gl, vertexShaderID, fragmentShaderID, attribute0) {
        function getTextContent(elementID) {
          var element = document.getElementById(elementID);
          var node = element.firstChild;
          var str = "";
          while (node) {
            if (node.nodeType == 3) str += node.textContent;
            node = node.nextSibling;
          }
          return str;
        }
        try {
          var vertexShaderSource = getTextContent(vertexShaderID);
          var fragmentShaderSource = getTextContent(fragmentShaderID);
        } catch (e) {
          throw "Error: Could not get shader source code from script elements.";
        }
        var vsh = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vsh, vertexShaderSource);
        gl.compileShader(vsh);
        if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {
          throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
        }
        var fsh = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fsh, fragmentShaderSource);
        gl.compileShader(fsh);
        if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {
          throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
        }
        var program = gl.createProgram();
        gl.attachShader(program, vsh);
        gl.attachShader(program, fsh);
        if (attribute0) {
          gl.bindAttribLocation(program, 0, attribute0);
        }
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          throw "Link error in program:  " + gl.getProgramInfoLog(program);
        }
        return program;
      }

      function frame() {
        if (isRunning) {
          updateData();
          render();
          requestAnimationFrame(frame);
        }
      }

      function handleResize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform1f(canvasWidthLoc, canvas.width);
        gl.uniform1f(canvasHeightLoc, canvas.height);
        if (!isRunning) {
          render();
        }
      }

      function handleMouse(evt) {
        function headTowards(x, y) {
          for (var i = 0; i < POINT_COUNT; i++) {
            var dx = x - positions[2 * i];
            var dy = y - positions[2 * i + 1];
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0.1) {
              var speed = Math.sqrt(
                velocities[2 * i] * velocities[2 * i] +
                  velocities[2 * i + 1] * velocities[2 * i + 1]
              );
              velocities[2 * i] = (dx / dist) * speed;
              velocities[2 * i + 1] = (dy / dist) * speed;
            }
          }
        }
        function move(evt) {
          headTowards(evt.clientX, evt.clientY);
        }
        function up() {
          canvas.removeEventListener("mousemove", move, false);
          document.removeEventListener("mouseup", up, false);
        }
        if (evt.which != 1) {
          return;
        }
        if (evt.shiftKey) {
          createData();
          return;
        }
        headTowards(evt.clientX, evt.clientY);
        canvas.addEventListener("mousemove", move);
        document.addEventListener("mouseup", up);
      }

      function init() {
        try {
          canvas = document.createElement("canvas");
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          var options = {
            alpha: false,
            depth: false,
            stencil: false,
          };
          gl = canvas.getContext("webgl", options);
          if (!gl) {
            throw "Browser does not support WebGL";
          }
        } catch (e) {
          var message = document.createElement("p");
          message.innerHTML =
            "Sorry, could not get a WebGL graphics context. Error: " + e;
          document.body.appendChild(message);
          return;
        }
        try {
          createData();
          initGL();
        } catch (e) {
          var message = document.createElement("p");
          message.innerHTML =
            "<pre>Sorry, could not initialize graphics context. Error:\n\n" +
            e +
            "</pre>";
          document.body.appendChild(message);
          return;
        }
        document.body.appendChild(canvas);
        window.addEventListener("resize", handleResize);
        canvas.addEventListener("mousedown", handleMouse);
        document.addEventListener("keydown", handleKey);
        requestAnimationFrame(frame);
      }
    </script>
  </head>
  <body onload="init()">
    <noscript>Sorry, this page requires JavaScript.</noscript>
  </body>
</html>
